<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Parqour ‚Ä¢ GOD MODE Hand Planet (Camera Fix)</title>
  <style>
    :root{
      --c1:#00f5ff; --c2:#a855f7; --c3:#22c55e; --c4:#ff2fd6;
      --txt: rgba(220,252,255,.92);
      --mut: rgba(220,252,255,.66);
      --glass: rgba(0,0,0,.26);
      --stroke: rgba(0,255,255,.16);
      --bg:#02040a;
    }
    html,body{margin:0;height:100%;background:radial-gradient(1200px 900px at 65% 12%, #0b1a44 0%, #060913 30%, var(--bg) 70%, #010209 100%);overflow:hidden;font-family:Inter,system-ui,Segoe UI,Arial}
    #wrap{position:relative;width:100%;height:100%}
    canvas{display:block}
    #three{position:absolute;inset:0}
    #handCanvas{position:absolute;inset:0;pointer-events:none}

    #gridfx{
      position:absolute;inset:-60px;pointer-events:none;opacity:.22;mix-blend-mode:screen;
      background:
        linear-gradient(to right, rgba(0,245,255,.06) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(0,245,255,.06) 1px, transparent 1px);
      background-size: 70px 70px;
      transform: perspective(900px) rotateX(66deg) translateY(120px);
      filter: blur(.2px);
      animation: drift 10s linear infinite;
    }
    @keyframes drift{0%{background-position:0 0}100%{background-position:140px 140px}}

    #fx{
      position:absolute;inset:0;pointer-events:none;mix-blend-mode:screen;opacity:.85;
      background:
        radial-gradient(1100px 800px at 18% 18%, rgba(168,85,247,.28), transparent 60%),
        radial-gradient(1200px 900px at 85% 65%, rgba(0,245,255,.26), transparent 65%),
        radial-gradient(900px 800px at 50% 100%, rgba(34,197,94,.12), transparent 62%),
        radial-gradient(700px 600px at 45% 45%, rgba(255,47,214,.10), transparent 55%);
      filter: blur(0.25px);
    }
    #vignette{
      position:absolute;inset:0;pointer-events:none;
      background:
        radial-gradient(circle at 50% 50%, rgba(0,0,0,0) 55%, rgba(0,0,0,.62) 100%),
        repeating-linear-gradient(0deg, rgba(255,255,255,.026) 0px, rgba(255,255,255,.026) 1px, rgba(0,0,0,0) 2px, rgba(0,0,0,0) 6px);
      opacity:.55;mix-blend-mode:multiply;
    }

    /* minimal HUD */
    #hud{
      position:absolute;left:16px;top:14px;
      background:var(--glass);
      border:1px solid var(--stroke);
      border-radius:14px;
      padding:10px 12px;
      color:var(--txt);
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 90px rgba(0,0,0,.45);
      display:flex;gap:10px;align-items:center;
      max-width:min(92vw, 820px);
    }
    .pill{
      padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);font-size:12px;color:var(--txt);white-space:nowrap
    }
    .mut{color:var(--mut);font-size:12px;white-space:nowrap}
    #hud b{font-weight:700}
    #hud .split{width:1px;height:22px;background:rgba(255,255,255,.10)}
    button{
      cursor:pointer;border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);color:var(--txt);
      border-radius:12px;padding:8px 10px;font-size:12px;
      transition:.15s transform,.15s background,.15s border;
      white-space:nowrap;
    }
    button:hover{transform: translateY(-1px);background:rgba(255,255,255,.09);border-color:rgba(0,245,255,.22)}
    button:active{transform: translateY(0px) scale(.99)}

    #toast{
      position:absolute;left:50%;bottom:24px;transform:translateX(-50%);
      padding:10px 14px;border-radius:999px;
      background:rgba(0,0,0,.35);border:1px solid rgba(0,255,255,.16);
      color:var(--txt);font-size:12px;backdrop-filter:blur(10px);
      opacity:0;transition:.2s;pointer-events:none
    }
    #toast.show{opacity:1}

    /* help modal */
    #modalBack{
      position:absolute;inset:0;background:rgba(0,0,0,.55);
      display:none;align-items:center;justify-content:center;
      backdrop-filter: blur(6px);
    }
    #modal{
      width:min(760px, 92vw);
      background:rgba(0,0,0,.40);
      border:1px solid rgba(0,255,255,.18);
      border-radius:18px;
      padding:16px 16px;
      color:var(--txt);
      box-shadow: 0 22px 110px rgba(0,0,0,.65);
    }
    #modal h2{margin:0 0 10px 0;font-size:16px;letter-spacing:.06em}
    #modal .grid{
      display:grid;grid-template-columns:1fr 1fr;gap:10px;
      font-size:13px;color:var(--mut);line-height:1.35;
    }
    #modal .card{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.05);
      border-radius:14px;padding:10px 10px;
    }
    #modal .card b{color:var(--txt)}
    #modal .foot{
      margin-top:12px;padding-top:10px;border-top:1px solid rgba(255,255,255,.10);
      display:flex;justify-content:space-between;gap:10px;align-items:center;
      font-size:12px;color:var(--mut)
    }
    #modal .dev{color:rgba(0,245,255,.95)}
    /* video hidden but active */
    #video{
      position:absolute;
      width:320px;height:240px;
      right:14px;bottom:14px;
      opacity:0.0; /* hidden; set to 0.12 if you want preview */
      transform: scaleX(-1);
      border-radius:14px;border:1px solid rgba(0,255,255,.12);
      background:#000;
      pointer-events:none;
    }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="three"></canvas>
  <canvas id="handCanvas"></canvas>
  <div id="gridfx"></div>
  <div id="fx"></div>
  <div id="vignette"></div>

  <div id="hud">
    <span class="pill" id="st">–û–∂–∏–¥–∞–Ω–∏–µ‚Ä¶</span>
    <span class="mut" id="mini">Parqour ‚Ä¢ by <b>Suleyman Rza</b></span>
    <span class="split"></span>
    <span class="pill" id="hands">–†—É–∫: 0</span>
    <span class="pill" id="fps">FPS: ‚Äî</span>
    <span class="pill" id="mode">GOD: OFF</span>
    <span class="split"></span>
    <button id="btnStart">–í–∫–ª—é—á–∏—Ç—å –∫–∞–º–µ—Ä—É</button>
    <button id="btnGest">–ñ–µ—Å—Ç—ã</button>
    <button id="btnGod">GOD MODE</button>
    <button id="btnReset">–°–±—Ä–æ—Å</button>
  </div>

  <div id="toast"></div>

  <div id="modalBack">
    <div id="modal">
      <h2>–ñ–µ—Å—Ç—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</h2>
      <div class="grid">
        <div class="card">
          <b>‚úã –õ–∞–¥–æ–Ω—å</b><br>
          –†–∞–∑—Ä—ã–≤–∞–µ—Ç –ø–ª–∞–Ω–µ—Ç—É (explode).
        </div>
        <div class="card">
          <b>‚úä –ö—É–ª–∞–∫</b><br>
          –°–æ–±–∏—Ä–∞–µ—Ç –ø–ª–∞–Ω–µ—Ç—É (implode).
        </div>
        <div class="card">
          <b>ü§è Pinch (–±–æ–ª—å—à–æ–π+—É–∫–∞–∑–∞—Ç–µ–ª—å–Ω—ã–π)</b><br>
          ‚ÄúSticky Drag Shard‚Äù ‚Äî –æ—Å–∫–æ–ª–æ–∫ –ø—Ä–∏–∫–ª–µ–∏–≤–∞–µ—Ç—Å—è –∫ –ø–∞–ª—å—Ü–∞–º –∏ —Å–ª–µ–¥—É–µ—Ç —Ç–æ—á–Ω–æ.
        </div>
        <div class="card">
          <b>ü§èü§è Pinch –¥–≤—É–º—è —Ä—É–∫–∞–º–∏</b><br>
          –ú–∞—Å—à—Ç–∞–± + —Å–∫—Ä—É—á–∏–≤–∞–Ω–∏–µ (twist).
        </div>
        <div class="card">
          <b>üî• –°–≤–∞—Ä–∫–∞ –ø–æ –ª–∏–Ω–∏–∏</b><br>
          –ë—ã—Å—Ç—Ä–æ –ø—Ä–æ–≤–µ–¥–∏ <b>–ª–∞–¥–æ–Ω—å—é</b> ‚Äî –æ—Å–∫–æ–ª–∫–∏ –≤ ‚Äú–∫–æ—Ä–∏–¥–æ—Ä–µ‚Äù –ª–∏–Ω–∏–∏ —É—Å–∫–æ—Ä–µ–Ω–Ω–æ —Å–æ–±–∏—Ä–∞—é—Ç—Å—è.
        </div>
        <div class="card">
          <b>‚å®Ô∏è –ö–ª–∞–≤–∏—à–∏</b><br>
          G ‚Äî GOD ‚Ä¢ R ‚Äî Reset ‚Ä¢ Space ‚Äî –ø–∞—É–∑–∞ ‚Ä¢ Q ‚Äî –∫–∞—á–µ—Å—Ç–≤–æ
        </div>
      </div>
      <div class="foot">
        <div>¬© Parqour ‚Äî –í—Å–µ –ø—Ä–∞–≤–∞ –∑–∞—â–∏—â–µ–Ω—ã ‚Ä¢ <span class="dev">Suleyman Rza</span></div>
        <button id="btnClose">–ó–∞–∫—Ä—ã—Ç—å</button>
      </div>
    </div>
  </div>

  <video id="video" autoplay playsinline muted></video>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";
    import { EffectComposer } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/postprocessing/EffectComposer.js";
    import { RenderPass } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/postprocessing/UnrealBloomPass.js";
    import { ShaderPass } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/postprocessing/ShaderPass.js";
    import { RGBShiftShader } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/shaders/RGBShiftShader.js";
    import { FilmPass } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/postprocessing/FilmPass.js";
    import { AfterimagePass } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/postprocessing/AfterimagePass.js";
    import { GlitchPass } from "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/postprocessing/GlitchPass.js";

    import { Hands } from "https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js";

    // ---------- UI ----------
    const el=(id)=>document.getElementById(id);
    const stEl=el("st"), handsEl=el("hands"), fpsEl=el("fps"), modeEl=el("mode");
    const btnStart=el("btnStart"), btnGest=el("btnGest"), btnGod=el("btnGod"), btnReset=el("btnReset");
    const toast=el("toast");
    const modalBack=el("modalBack"), btnClose=el("btnClose");
    const video=el("video");

    function notify(msg){
      toast.textContent=msg;
      toast.classList.add("show");
      clearTimeout(notify._t);
      notify._t=setTimeout(()=>toast.classList.remove("show"), 950);
    }

    // ---------- Helpers ----------
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp=(a,b,t)=>a+(b-a)*t;

    // ---------- Canvas ----------
    const canvas3=el("three");
    const handCanvas=el("handCanvas");
    const hctx=handCanvas.getContext("2d");

    // ---------- Modes ----------
    const modes={
      god:false,
      weld:true,
      overlay:true,
      freeze:false,
      highQuality:true,

      // post
      bloom:true,
      after:true,
      rgb:false,
      film:true,
      glitch:false,

      // vibe
      nebula:true,
      colorCycle:true,
      vortex:false,
      pulseCam:true
    };

    // ---------- Three ----------
    const renderer=new THREE.WebGLRenderer({canvas:canvas3, antialias:true, alpha:true});
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));

    const scene=new THREE.Scene();
    scene.fog=new THREE.FogExp2(0x02040a, 0.085);

    const cam3=new THREE.PerspectiveCamera(55,1,0.1,1000);
    cam3.position.set(0,0,4.35);

    const root=new THREE.Group();
    scene.add(root);

    scene.add(new THREE.AmbientLight(0xffffff,0.55));
    const key=new THREE.DirectionalLight(0xffffff,0.55);
    key.position.set(2,2,3);
    scene.add(key);

    // post chain
    const composer=new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, cam3));

    const bloom=new UnrealBloomPass(new THREE.Vector2(1,1), 1.25, 0.75, 0.02);
    composer.addPass(bloom);

    const after=new AfterimagePass();
    after.uniforms["damp"].value=0.92;
    composer.addPass(after);

    const rgb=new ShaderPass(RGBShiftShader);
    rgb.uniforms["amount"].value=0.0;
    composer.addPass(rgb);

    const film=new FilmPass(0.22, 0.35, 1080, false);
    composer.addPass(film);

    const glitch=new GlitchPass();
    glitch.enabled=false;
    composer.addPass(glitch);

    function resize(){
      const w=innerWidth,h=innerHeight;
      renderer.setSize(w,h,false);
      composer.setSize(w,h);
      cam3.aspect=w/h; cam3.updateProjectionMatrix();
      handCanvas.width=w; handCanvas.height=h;
    }
    addEventListener("resize", resize); resize();

    // background stars
    const STAR_N=12000;
    const starGeo=new THREE.BufferGeometry();
    const starPos=new Float32Array(STAR_N*3);
    for(let i=0;i<STAR_N;i++){
      const r=30*Math.random()+10;
      const a=Math.random()*Math.PI*2;
      const b=(Math.random()*2-1)*Math.PI/2;
      starPos[i*3+0]=Math.cos(a)*Math.cos(b)*r;
      starPos[i*3+1]=Math.sin(b)*r;
      starPos[i*3+2]=Math.sin(a)*Math.cos(b)*r;
    }
    starGeo.setAttribute("position", new THREE.BufferAttribute(starPos,3));
    const stars=new THREE.Points(starGeo, new THREE.PointsMaterial({size:0.02, transparent:true, opacity:0.78, depthWrite:false}));
    scene.add(stars);

    const haze=new THREE.Mesh(
      new THREE.SphereGeometry(3.3,44,44),
      new THREE.MeshBasicMaterial({color:0x1b2a6b, transparent:true, opacity:0.085, side:THREE.BackSide})
    );
    scene.add(haze);

    // ---------- Planet (fast shards) ----------
    const quality=()=> modes.highQuality ? {N:22000,S:56} : {N:14000,S:40};

    function randUnitVec(){
      const u=Math.random(), v=Math.random();
      const th=2*Math.PI*u;
      const ph=Math.acos(2*v-1);
      return new THREE.Vector3(Math.sin(ph)*Math.cos(th), Math.cos(ph), Math.sin(ph)*Math.sin(th));
    }

    let P=null;
    function buildPlanet(){
      const {N,S}=quality();
      const base=new Float32Array(N*3);
      const cur =new Float32Array(N*3);
      const col =new Float32Array(N*3);
      const sid =new Uint16Array(N);

      const seeds=[];
      for(let s=0;s<S;s++) seeds.push(randUnitVec());

      const disp=new Float32Array(S*3);
      const vel =new Float32Array(S*3);
      const tgt =new Float32Array(S*3);
      const weldBoost=new Float32Array(S);

      for(let i=0;i<N;i++){
        const u=Math.random(), v=Math.random();
        const th=2*Math.PI*u;
        const ph=Math.acos(2*v-1);
        const r=1.23 + (Math.random()-0.5)*0.05;
        const x=r*Math.sin(ph)*Math.cos(th);
        const y=r*Math.cos(ph);
        const z=r*Math.sin(ph)*Math.sin(th);

        base[i*3]=x; base[i*3+1]=y; base[i*3+2]=z;
        cur[i*3]=x;  cur[i*3+1]=y;  cur[i*3+2]=z;

        const p=new THREE.Vector3(x,y,z).normalize();
        let best=-999, bi=0;
        for(let s=0;s<S;s++){
          const d=p.dot(seeds[s]);
          if(d>best){best=d;bi=s;}
        }
        sid[i]=bi;

        const t=Math.random();
        col[i*3+0]=lerp(0.06,0.35,t);
        col[i*3+1]=lerp(0.78,1.00,t);
        col[i*3+2]=lerp(0.88,1.00,1-t);
      }

      const geo=new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.BufferAttribute(cur,3));
      geo.setAttribute("color", new THREE.BufferAttribute(col,3));

      const mat=new THREE.PointsMaterial({
        size:0.012,
        transparent:true,
        opacity:0.95,
        vertexColors:true,
        depthWrite:false
      });

      const pts=new THREE.Points(geo, mat);
      pts.frustumCulled=false;
      root.add(pts);

      return {N,S, base,cur,col, sid,seeds, disp,vel,tgt,weldBoost, geo, pts};
    }

    function rebuildPlanet(){
      if(P){
        root.remove(P.pts);
        P.geo.dispose();
        P.pts.material.dispose();
      }
      P=buildPlanet();
      notify(`–ü–ª–∞–Ω–µ—Ç–∞: shards=${P.S}`);
    }
    rebuildPlanet();

    // ---------- Interaction physics ----------
    let targetExplode=0, explode=0;
    let rotVelX=0, rotVelY=0;
    let baseScale=1.0;
    let godEnergy=0;
    let timeScale=1.0;

    function explodeOn(){ targetExplode=1; godEnergy=Math.min(1,godEnergy+0.12); }
    function explodeOff(){ targetExplode=0; }

    function resetAll(){
      targetExplode=0; explode=0;
      rotVelX=rotVelY=0;
      baseScale=1.0;
      godEnergy=0;
      if(P){
        P.disp.fill(0); P.vel.fill(0); P.tgt.fill(0); P.weldBoost.fill(0);
      }
      for(let i=0;i<2;i++){ grab[i].active=false; grab[i].sid=-1; }
      weld.active=false;
      notify("–°–±—Ä–æ—Å");
    }

    // ---------- Screen->World ----------
    function worldFromScreen(x,y){
      const nx=(x/handCanvas.width)*2-1;
      const ny=-(y/handCanvas.height)*2+1;
      return new THREE.Vector3(nx*1.25, ny*0.85, 0.25);
    }

    // ---------- Hand overlay + gesture classification ----------
    function lmToScreen(lm){
      return { x:(1-lm.x)*handCanvas.width, y:lm.y*handCanvas.height }; // mirror X
    }
    function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }

    function classify(landmarks){
      const p4=lmToScreen(landmarks[4]);
      const p8=lmToScreen(landmarks[8]);
      const p12=lmToScreen(landmarks[12]);
      const p16=lmToScreen(landmarks[16]);
      const p20=lmToScreen(landmarks[20]);
      const wrist=lmToScreen(landmarks[0]);

      const pinchD=Math.sqrt(dist2(p4,p8));
      const spread=0.5*(Math.hypot(p8.x-p20.x,p8.y-p20.y)+Math.hypot(p12.x-p16.x,p12.y-p16.y));

      const pinch=pinchD<40;
      const palm=(spread>190)&&(pinchD>60);
      const fist=(spread<135)&&(pinchD>48);

      const strength=clamp(1-(pinchD/40),0,1);

      let name="–î–≤–∏–∂–µ–Ω–∏–µ";
      if(palm) name="–õ–∞–¥–æ–Ω—å";
      else if(fist) name="–ö—É–ª–∞–∫";
      else if(pinch) name="Pinch";

      return { name, pinch, palm, fist, point: pinch?p8:wrist, pinchStrength:strength };
    }

    function drawHand(landmarks, color="rgba(0,245,255,.92)", tip="rgba(255,47,214,.95)"){
      if(!modes.overlay) return;
      const pts=landmarks.map(lmToScreen);
      const chains=[[0,1,2,3,4],[0,5,6,7,8],[0,9,10,11,12],[0,13,14,15,16],[0,17,18,19,20],[5,9,13,17]];

      hctx.lineWidth=2.35;
      hctx.strokeStyle=color;
      hctx.shadowColor="rgba(0,245,255,.65)";
      hctx.shadowBlur=14;

      for(const ch of chains){
        hctx.beginPath();
        for(let i=0;i<ch.length;i++){
          const p=pts[ch[i]];
          if(i===0) hctx.moveTo(p.x,p.y); else hctx.lineTo(p.x,p.y);
        }
        hctx.stroke();
      }

      for(let i=0;i<pts.length;i++){
        const p=pts[i];
        hctx.beginPath();
        const r=(i===8||i===4)?6.4:4.2;
        hctx.fillStyle=(i===8||i===4)?tip:"rgba(220,252,255,.95)";
        hctx.shadowColor=(i===8||i===4)?"rgba(255,47,214,.75)":"rgba(0,245,255,.45)";
        hctx.shadowBlur=(i===8||i===4)?22:12;
        hctx.arc(p.x,p.y,r,0,Math.PI*2);
        hctx.fill();
      }
      hctx.shadowBlur=0;
    }

    // ---------- Sticky drag shards ----------
    const handsState=[
      {ok:false, pinch:false, palm:false, fist:false, name:"‚Äî", scr:{x:0,y:0}, w:new THREE.Vector3(), strength:0, vel:0},
      {ok:false, pinch:false, palm:false, fist:false, name:"‚Äî", scr:{x:0,y:0}, w:new THREE.Vector3(), strength:0, vel:0},
    ];

    const grab=[
      {active:false, sid:-1, offset:new THREE.Vector3(), target:new THREE.Vector3(), smooth:new THREE.Vector3()},
      {active:false, sid:-1, offset:new THREE.Vector3(), target:new THREE.Vector3(), smooth:new THREE.Vector3()},
    ];

    function pickShard(dir){
      let best=-999, bi=0;
      for(let s=0;s<P.S;s++){
        const d=dir.dot(P.seeds[s]);
        if(d>best){best=d;bi=s;}
      }
      return bi;
    }

    // ---------- Weld line ----------
    const weld={active:false, a:new THREE.Vector3(), b:new THREE.Vector3(), ttl:0.0, aScr:null, bScr:null};

    function drawWeldLine(){
      if(!modes.overlay || !weld.active || !weld.aScr || !weld.bScr) return;
      hctx.save();
      hctx.lineWidth=6;
      hctx.strokeStyle="rgba(0,245,255,.60)";
      hctx.shadowColor="rgba(0,245,255,.85)";
      hctx.shadowBlur=26;
      hctx.beginPath();
      hctx.moveTo(weld.aScr.x, weld.aScr.y);
      hctx.lineTo(weld.bScr.x, weld.bScr.y);
      hctx.stroke();
      hctx.restore();
    }

    function distPointToSeg(px,py,pz, ax,ay,az, bx,by,bz){
      const abx=bx-ax, aby=by-ay, abz=bz-az;
      const apx=px-ax, apy=py-ay, apz=pz-az;
      const ab2=abx*abx+aby*aby+abz*abz;
      if(ab2<1e-6) return Math.hypot(apx,apy,apz);
      let t=(apx*abx+apy*aby+apz*abz)/ab2;
      t=clamp(t,0,1);
      const cx=ax+abx*t, cy=ay+aby*t, cz=az+abz*t;
      return Math.hypot(px-cx,py-cy,pz-cz);
    }

    // ---------- MediaPipe Hands setup ----------
    const mpHands=new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`
    });
    mpHands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.74,
      minTrackingConfidence: 0.74
    });

    let cameraRunning=false;
    let lastVideoTime=-1;

    mpHands.onResults((res)=>{
      const lms=res.multiHandLandmarks||[];
      const count=Math.min(2,lms.length);

      handsEl.textContent="–†—É–∫: "+count;

      hctx.clearRect(0,0,handCanvas.width,handCanvas.height);

      for(let i=0;i<2;i++){
        handsState[i].ok=false;
        handsState[i].name="‚Äî";
        handsState[i].pinch=false; handsState[i].palm=false; handsState[i].fist=false;
        handsState[i].strength=0; handsState[i].vel=0;
      }

      if(count===0){
        stEl.textContent = cameraRunning ? "–ö–∞–º–µ—Ä–∞ ON ‚Ä¢ —Ä—É–∫ –Ω–µ—Ç" : "–û–∂–∏–¥–∞–Ω–∏–µ‚Ä¶";
        for(let i=0;i<2;i++){ grab[i].active=false; grab[i].sid=-1; }
        return;
      }

      stEl.textContent="–ö–∞–º–µ—Ä–∞ ON ‚Ä¢ —Ç—Ä–µ–∫–∏–Ω–≥";

      const gestText=[];
      for(let i=0;i<count;i++){
        const lm=lms[i];
        const g=classify(lm);

        handsState[i].ok=true;
        handsState[i].name=g.name;
        handsState[i].pinch=g.pinch;
        handsState[i].palm=g.palm;
        handsState[i].fist=g.fist;
        handsState[i].scr=g.point;
        handsState[i].w.copy(worldFromScreen(g.point.x, g.point.y));
        handsState[i].strength=g.pinchStrength;

        // velocity for weld gesture
        if(!handsState[i]._last){ handsState[i]._last={x:g.point.x,y:g.point.y}; handsState[i].vel=0; }
        const dx=g.point.x-handsState[i]._last.x;
        const dy=g.point.y-handsState[i]._last.y;
        handsState[i].vel=Math.hypot(dx,dy);
        handsState[i]._last.x=g.point.x; handsState[i]._last.y=g.point.y;

        // rotation from motion
        rotVelY += dx*0.000030;
        rotVelX += dy*0.000026;

        const col=i===0?"rgba(0,245,255,.92)":"rgba(34,197,94,.92)";
        const tip=i===0?"rgba(255,47,214,.95)":"rgba(0,245,255,.95)";
        drawHand(lm, col, tip);

        gestText.push((i===0?"1":"2")+": "+g.name);
      }

      // global palm/fist
      const anyPalm=handsState.some(h=>h.ok && h.palm);
      const anyFist=handsState.some(h=>h.ok && h.fist);
      if(anyPalm) explodeOn();
      else if(anyFist) explodeOff();

      // two-hand pinch => scale + twist
      if(count===2 && handsState[0].pinch && handsState[1].pinch){
        const p0=handsState[0].scr, p1=handsState[1].scr;
        const d=Math.hypot(p0.x-p1.x, p0.y-p1.y);
        if(!mpHands._pinch0) mpHands._pinch0=d;
        const s=clamp(d/mpHands._pinch0, 0.65, 1.65);
        baseScale = lerp(baseScale, s, 0.24);
        rotVelY += (p1.x-p0.x)*0.0000022;
        godEnergy = Math.min(1, godEnergy+0.012);
      } else {
        mpHands._pinch0=null;
      }

      // sticky grabs
      for(let i=0;i<2;i++){
        if(!handsState[i].ok){ grab[i].active=false; grab[i].sid=-1; continue; }
        const isPinch=handsState[i].pinch;

        if(isPinch && !grab[i].active){
          const dir=handsState[i].w.clone().normalize();
          const sid=pickShard(dir);
          grab[i].sid=sid;
          grab[i].active=true;

          const sx=P.disp[sid*3+0], sy=P.disp[sid*3+1], sz=P.disp[sid*3+2];
          grab[i].offset.set(sx,sy,sz).sub(handsState[i].w);
          grab[i].smooth.copy(handsState[i].w);
          godEnergy=Math.min(1, godEnergy+0.03);
        }

        if(isPinch && grab[i].active){
          grab[i].smooth.lerp(handsState[i].w, 0.35);
          grab[i].target.copy(grab[i].smooth).add(grab[i].offset);
        }

        if(!isPinch && grab[i].active){
          grab[i].active=false;
          grab[i].sid=-1;
        }
      }

      // weld gesture: palm + fast move
      if(modes.weld){
        const palmIdx=handsState.findIndex(h=>h.ok && h.palm);
        if(palmIdx!==-1 && handsState[palmIdx].vel>35){
          const curW=handsState[palmIdx].w.clone();
          const curS=handsState[palmIdx].scr;

          if(!weld.active){
            weld.active=true;
            weld.a.copy(curW);
            weld.b.copy(curW);
            weld.ttl=0.22;
            weld.aScr={x:curS.x,y:curS.y};
            weld.bScr={x:curS.x,y:curS.y};
          } else {
            weld.a.copy(weld.b);
            weld.b.copy(curW);
            weld.ttl=0.22;
            weld.aScr={x:weld.bScr.x,y:weld.bScr.y};
            weld.bScr={x:curS.x,y:curS.y};
          }
          godEnergy=Math.min(1, godEnergy+0.02);
        }
      }

      // show mode
      modeEl.textContent = "GOD: " + (modes.god ? "ON" : "OFF") + (modes.weld ? " ‚Ä¢ WELD" : "");
    });

    // ---------- Camera start: MUST be user click ----------
    async function startCamera(){
      // HTTPS warning
      if(location.protocol !== "https:" && location.hostname !== "localhost"){
        notify("‚ö† –ö–∞–º–µ—Ä–∞ —Ç—Ä–µ–±—É–µ—Ç HTTPS –∏–ª–∏ localhost");
      }

      try{
        stEl.textContent="–ó–∞–ø—Ä–æ—Å –∫–∞–º–µ—Ä—ã‚Ä¶";
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: "user",
            width: { ideal: 1280 },
            height:{ ideal: 720 }
          },
          audio:false
        });
        video.srcObject = stream;
        await video.play();

        cameraRunning=true;
        btnStart.textContent="–ö–∞–º–µ—Ä–∞: ON";
        btnStart.disabled=true;
        notify("–ö–∞–º–µ—Ä–∞ –≤–∫–ª—é—á–µ–Ω–∞");

        // Start processing loop
        requestAnimationFrame(processFrame);
      } catch(err){
        console.error(err);
        cameraRunning=false;
        stEl.textContent="–ö–∞–º–µ—Ä–∞ OFF";
        notify("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –≤–∫–ª—é—á–∏—Ç—å –∫–∞–º–µ—Ä—É (—Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è/HTTPS)");
      }
    }

    async function processFrame(){
      if(!cameraRunning) return;

      // reduce calls: only when new frame
      if(video.readyState >= 2 && video.currentTime !== lastVideoTime){
        lastVideoTime = video.currentTime;
        await mpHands.send({ image: video });
      }
      requestAnimationFrame(processFrame);
    }

    btnStart.onclick = startCamera;

    // ---------- Modal ----------
    btnGest.onclick=()=>{ modalBack.style.display="flex"; };
    btnClose.onclick=()=>{ modalBack.style.display="none"; };
    modalBack.addEventListener("click",(e)=>{ if(e.target===modalBack) modalBack.style.display="none"; });

    // ---------- GOD button ----------
    btnGod.onclick=()=>{
      modes.god = !modes.god;
      if(modes.god){
        modes.bloom=true; modes.after=true; modes.film=true; modes.rgb=true;
        after.uniforms["damp"].value=0.90;
        notify("GOD MODE: ON");
      } else {
        modes.rgb=false;
        after.uniforms["damp"].value=0.92;
        notify("GOD MODE: OFF");
      }
      modeEl.textContent="GOD: "+(modes.god?"ON":"OFF")+(modes.weld?" ‚Ä¢ WELD":"");
    };

    btnReset.onclick=resetAll;

    addEventListener("keydown",(e)=>{
      if(e.code==="KeyG") btnGod.click();
      if(e.code==="KeyR") resetAll();
      if(e.code==="Space"){ modes.freeze=!modes.freeze; notify("–ü–∞—É–∑–∞: "+(modes.freeze?"ON":"OFF")); }
      if(e.code==="KeyQ"){ modes.highQuality=!modes.highQuality; rebuildPlanet(); notify("–ö–∞—á–µ—Å—Ç–≤–æ: "+(modes.highQuality?"HIGH":"MED")); }
    });

    // ---------- Animation loop ----------
    function integrateShards(dt){
      const baseK=10.2;
      const damp=0.88;

      for(let s=0;s<P.S;s++){
        const ix=s*3;
        const tx=P.tgt[ix+0], ty=P.tgt[ix+1], tz=P.tgt[ix+2];
        const boost=P.weldBoost[s];
        const k=baseK + boost*26.0;

        P.vel[ix+0] = (P.vel[ix+0] + (tx - P.disp[ix+0]) * k * dt) * damp;
        P.vel[ix+1] = (P.vel[ix+1] + (ty - P.disp[ix+1]) * k * dt) * damp;
        P.vel[ix+2] = (P.vel[ix+2] + (tz - P.disp[ix+2]) * k * dt) * damp;

        // subtle vortex
        if(modes.vortex){
          const vx = -P.disp[ix+2]*0.65;
          const vz =  P.disp[ix+0]*0.65;
          P.vel[ix+0] += vx*dt*0.9;
          P.vel[ix+2] += vz*dt*0.9;
        }

        P.disp[ix+0] += P.vel[ix+0]*dt;
        P.disp[ix+1] += P.vel[ix+1]*dt;
        P.disp[ix+2] += P.vel[ix+2]*dt;

        P.weldBoost[s]=Math.max(0, boost - dt*2.8);
      }
    }

    function updatePlanet(t){
      const pulse = 1 + Math.sin(t*1.75)*0.012;
      const base=P.base, cur=P.cur, sid=P.sid, disp=P.disp;

      for(let i=0;i<P.N;i++){
        const ix=i*3;
        const s = sid[i]*3;
        cur[ix+0]=base[ix+0]*pulse + disp[s+0];
        cur[ix+1]=base[ix+1]*pulse + disp[s+1];
        cur[ix+2]=base[ix+2]*pulse + disp[s+2];
      }
      P.geo.attributes.position.needsUpdate=true;

      if(modes.colorCycle){
        const arr=P.geo.attributes.color.array;
        const w=0.5+0.5*Math.sin(t*0.9);
        for(let i=0;i<Math.min(1800,P.N);i++){
          const j=i*3;
          arr[j+0]=lerp(arr[j+0], 0.06+0.35*w, 0.08);
          arr[j+1]=lerp(arr[j+1], 0.78+0.22*(1-w), 0.08);
          arr[j+2]=lerp(arr[j+2], 0.92+0.08*w, 0.08);
        }
        P.geo.attributes.color.needsUpdate=true;
      }
    }

    let t0=performance.now(), acc=0, cnt=0;
    function render(now){
      requestAnimationFrame(render);

      const rawDt=Math.min(0.033, (now-t0)/1000);
      t0=now;

      // fps
      acc += 1/rawDt; cnt++;
      if(cnt>=18){ fpsEl.textContent="FPS: "+Math.round(acc/cnt); acc=0; cnt=0; }

      if(modes.freeze){
        composer.render();
        return;
      }

      // time scaling (god vibe)
      timeScale = lerp(timeScale, modes.god ? 0.92 : 1.0, 0.04);
      const dt = rawDt * timeScale;
      const t = now/1000;

      // decay god energy
      godEnergy = Math.max(0, godEnergy - rawDt*0.08);

      // explode smoothing
      explode = lerp(explode, targetExplode, 1 - Math.pow(0.001, dt));

      // root rotation (auto)
      root.rotation.y += dt*0.24;
      root.rotation.x += dt*0.06;
      root.rotation.x += rotVelX;
      root.rotation.y += rotVelY;
      rotVelX *= 0.93; rotVelY *= 0.93;

      // scale
      root.scale.setScalar(lerp(root.scale.x, baseScale, 0.15));

      // bg drift
      stars.rotation.y += dt*0.02;
      haze.rotation.y -= dt*0.03;
      haze.rotation.x += dt*0.01;

      // camera pulse
      const p = modes.pulseCam ? (1 + Math.sin(t*1.2)*0.018*(0.35+godEnergy)) : 1;
      cam3.fov = lerp(cam3.fov, 55*p, 0.08);
      cam3.updateProjectionMatrix();
      cam3.position.x = Math.sin(t*0.25)*0.06*(1+godEnergy*0.6);
      cam3.position.y = Math.cos(t*0.22)*0.05*(1+godEnergy*0.6);
      cam3.lookAt(0,0,0);

      // targets
      const push = explode * (modes.god ? 1.35 : 1.15);
      for(let s=0;s<P.S;s++){
        const seed=P.seeds[s];
        P.tgt[s*3+0]=seed.x*push;
        P.tgt[s*3+1]=seed.y*push;
        P.tgt[s*3+2]=seed.z*push;
      }

      // sticky grabs
      for(let i=0;i<2;i++){
        if(grab[i].active && grab[i].sid>=0){
          const sid = grab[i].sid;
          const str = lerp(0.95, 1.65, handsState[i]?.strength ?? 0.6);
          P.tgt[sid*3+0] = lerp(P.tgt[sid*3+0], grab[i].target.x, 0.70) * str;
          P.tgt[sid*3+1] = lerp(P.tgt[sid*3+1], grab[i].target.y, 0.70) * str;
          P.tgt[sid*3+2] = lerp(P.tgt[sid*3+2], grab[i].target.z, 0.70) * str;
        }
      }

      // weld
      if(weld.active && modes.weld){
        weld.ttl -= dt;
        if(weld.ttl<=0){
          weld.active=false;
          weld.aScr=weld.bScr=null;
        } else {
          const corridor = modes.god ? 0.26 : 0.22;
          const ax=weld.a.x, ay=weld.a.y, az=weld.a.z;
          const bx=weld.b.x, by=weld.b.y, bz=weld.b.z;
          for(let s=0;s<P.S;s++){
            const ix=s*3;
            const px=P.disp[ix+0], py=P.disp[ix+1], pz=P.disp[ix+2];
            const d=distPointToSeg(px,py,pz, ax,ay,az, bx,by,bz);
            if(d<corridor){
              const k=(1-d/corridor);
              P.weldBoost[s]=Math.min(1, P.weldBoost[s] + k*dt*7.0);
              P.tgt[ix+0]*=0.45;
              P.tgt[ix+1]*=0.45;
              P.tgt[ix+2]*=0.45;
              godEnergy=Math.min(1, godEnergy+0.01);
            }
          }
          weld.a.lerp(weld.b, 0.08);
        }
      }

      integrateShards(dt);
      updatePlanet(t);

      // overlay extras
      drawWeldLine();

      // post toggles
      bloom.strength = modes.bloom ? (modes.god ? (1.35 + Math.sin(t*0.9)*0.35 + godEnergy*0.55) : (1.10 + Math.sin(t*0.9)*0.25)) : 0.0;
      after.enabled = !!modes.after;
      rgb.enabled = !!modes.rgb;
      rgb.uniforms["amount"].value = modes.rgb ? (0.0022 + godEnergy*0.004) : 0.0;
      film.enabled = !!modes.film;
      glitch.enabled = !!modes.glitch;

      composer.render();
    }
    requestAnimationFrame(render);

    // ---------- camera status ----------
    stEl.textContent="–ö–∞–º–µ—Ä–∞ OFF ‚Ä¢ –Ω–∞–∂–º–∏ ¬´–í–∫–ª—é—á–∏—Ç—å –∫–∞–º–µ—Ä—É¬ª";
    notify("–ù–∞–∂–º–∏ ¬´–í–∫–ª—é—á–∏—Ç—å –∫–∞–º–µ—Ä—É¬ª –¥–ª—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –¥–æ—Å—Ç—É–ø–∞");

    // ---------- safety: if camera API missing ----------
    if(!navigator.mediaDevices?.getUserMedia){
      stEl.textContent="–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ getUserMedia";
      notify("–ë—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∫–∞–º–µ—Ä—É");
      btnStart.disabled=true;
    }
  </script>
</div>
</body>
</html>
